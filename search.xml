<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mac os 结束占用端口]]></title>
    <url>%2F2018%2F10%2F08%2Fmac-os-%E7%BB%93%E6%9D%9F%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1.打开终端，输入命令1lsof -i:**** // 端口号 2.结束端口进程1kill ****]]></content>
  </entry>
  <entry>
    <title><![CDATA[飞流工作总结]]></title>
    <url>%2F2018%2F10%2F08%2F%E9%A3%9E%E6%B5%81%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、主要工作内容1.游戏官网与预约页开发 静态页面 ——v1版网站啪啪三国（网站页面修改和后期维护）成都飞流官网（旧版）（网站页面修改和后期维护）三国群英传（网站页面修改和后期维护） PHP(CI框架)+原生页面 ——v2版网站九州官网（后期维护）天下第一剑客传官网（后台开发及部署上线、部分页面开发、http://txdyjkz.feiliu.com）墨三国官网（后台开发及部署上线、http://mosanguo.feiliu.com）啪啪三国2官网（后台开发及部署上线、http://papa2.feiliu.com/）全职高手预约页（后台开发及部署）傲世群英传-破千军预约页（后台开发及部署上线，不同渠道进入页面二维码功能、http://asyuyue.feiliu.com）雄霸乱世预约页（后台开发及部署上线、http://xb.feiliu.com/register） Node.js + vue.js ——v3版网站傲世群英传-破千军官网（协助伟杰开发后台并初步接触sequelize 和 jest、http://asqyz.feiliu.com ）繁体官网（无后台页面维护，现已转到game_v3公共后台）忍者龟官网（参与后台开发，项目已下线）成都官网（前期静态页面维护，现已转到game_v3公共后台、http://www.feiliuchengdu.com）game_v3共同后台开发（account相关接口的开发，登录注册重置密码。。。）game_v3前端模板开发（template，第一版官网共同模板，第一版预约页共同模板） 2.land（落地页工作） 落地页前端页面三国群英传落地页（多个）傲世群英传落地页（多个） land第三方推广地址适配（nginx配置及land后台配置）三国群英传泰坦大陆傲世群英传 land后期维护熟悉admin_land和land_feiliu项目（node+vue+mysql项目）后期维护工作，添加统计落地页访问记录和下载点击记录功能 3.gas后台管理系统使用（广点通和积分墙两种信息对接）测试 联调 排bug 查询日志微信广告通过广点通的方式接入GAS 4.微信积分商城天下第一剑客传积分商城（测试环境搭建，API接口路径修改，bug修改，礼包限制等功能添加，活动礼包投放）啪啪三国2积分商城（测试环境搭建，API接口路径修改，bug修改，礼包限制等功能添加，活动礼包投放）忍者龟积分商城和bug反馈系统（后台开发，项目已下线） 5.数据统计九州（日常数据统计，不定时礼包投放，excle 合并入库脚本，积分入库）天下第一剑客传积分商城（日常数据统计，签到礼包实物礼包活动投放，礼包码入库）啪啪三国2积分商城（日常数据统计，签到礼包实物礼包活动投放，礼包码入库）墨三国预约（数据统计）傲世群英传-破千军（日常预约人数统计，渠道来源统计） 达到的水平：能够完成线上网站（v1版、v2版、v3版）的维护，对网站管理后台系统能够熟练使用能够独立完成包括公司官网、游戏官网、游戏预约网站的后端开发以及前端页面的开发能够完成游戏积分商城的维护以及活动礼包投放的工作能够高效完成land落地页的制作以及第三方推广地址适配工作能够完成gas对接、联调、测试等工作 二、工作中的收获技术层次上，第一次接触CI框架和smarty模板，对php和nginx有了一定的了解，与服务器和数据库打交道，掌握了更多便捷的Linux命令以及sql语句，在网站v3版开发过程中，深入学习了node的express框架、sequelize 和 jest，自己的vue水平也有了一定的提高； 工作方法上，项目开发流程进一步优化，按照项目工期制定计划，明确的各个时间点，按时完成集成验收和功能验收，提高工作效率，还有通过代码review的方式，接收采纳团队提出建议，进一步完善优化代码，项目API文档化，条理清晰地记录项目所需的各种信息。 三、工作中的问题 前期的功能设计需要加强 不足：喜欢做完一步再想下一步，缺乏整体设计，没有前期设计把关，方案不是最优的情况下花费的代价和优化的代价都大。 改进：“以终为始”考虑问题，要明确自己的目标，再去设计接下去的路，否则规划只是空话，再有新的工作又会觉得计划没有变化快了。 单元测试需要加强 不足：单元测试意识淡薄，业务功能没有对应的单元测试容易出现问题，“傲世群英传-破千军”的预约页和“雄霸乱世”预约页进行后期维护，一次替换成测试环境的接口，一次把官网后台的功能去掉，都是没有进行完整测试造成的，测试工作对整个项目的重要性是不可代替的。 改进：接下去的工作，应及时完善接口API文档和对应的单元测试，项目维护变更功能必须及时更新相应的单元测试，然后进行完善的全面的测试确保功能没有问题之后，才可以部署到正式环境，对其他部门提供服务。 四、后续计划现有项目的文档补充和代码优化（API文档、ALM文档、单元测试）网站v3版二期 （公共后台优化、前端模板的开发）// 这套网站系统是我们工作的核心后台管理系统的学习（open系统、sso系统、cs系统）]]></content>
  </entry>
  <entry>
    <title><![CDATA[git多账号配置]]></title>
    <url>%2F2018%2F09%2F26%2Fgit%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[思路 ssh 方式链接到 Github／Gerrit，需要唯一的公钥，如果想同一台电脑绑定两个Github/Gerrit帐号，需要两个条件: 1.能够生成两对 私钥/公钥 2.push 时，可以区分两个账户，推送到相应的仓库 操作方法 Mac 下输入命令 ls ~/.ssh/，看到 id_rsa 与 id_rsa_pub 则说明已经有一对密钥 生成新的公钥，并命名为 id_rsa_2 (保证与之前密钥文件名称不同即可,文件名最好有意义，否则写后面的配置的时候写错文件名，我的文件名是id_rsa_coffeehouse） 1ssh-keygen -t rsa -f ~/.ssh/id_rsa_2 -C "yourmail@xxx.com" 在 .ssh 文件夹下新建 config 文件并编辑，令不同 Host 实际映射到同一HostName，但密钥文件不同。Host 前缀可自定义。 12345678910111213#osOneHost feiliu // 别名HostName 172.16.***.*** // 主机名可用ip也可以是域名Port 29418 // 服务器open-ssh端口User qiuzhaopeng // 登录用户名IdentityFile ~/.ssh/id_rsa // 证书文件路径#osTwoHost github.comHostName github.comUser CoffeeHouse1122IdentityFile ~/.ssh/id_rsa_coffeehouse 将id_rsa_coffeehouse.pub的密钥copy到github账号配置SSH keys中 测试 (可跳过) 12ssh -T feiliussh -T github.com 将项目 clone 到本地, git push 测试一下]]></content>
  </entry>
  <entry>
    <title><![CDATA[js高级]]></title>
    <url>%2F2018%2F08%2F15%2Fjs%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[JavaScript 高级案例演示 贪吃蛇 JavaScript 是什么 解析执行：轻量级解释型的，或是 JIT 编译型的程序设计语言 语言特点：动态，头等函数 (First-class Function) 又称函数是 JavaScript 中的一等公民 执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境 但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js 编程范式：基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格 JavaScript 与浏览器的关系 JavaScript 的组成 组成部分 说明 Ecmascript 描述了该语言的语法和基本对象 DOM 描述了处理网页内容的方法和接口 BOM 描述了与浏览器进行交互的方法和接口 JavaScript 可以做什么 Any application that can be written in JavaScript, will eventually be written in JavaScript.凡是能用 JavaScript 写出来的，最终都会用 JavaScript 写出来 知乎 - JavaScript 能做什么，该做什么？ 最流行的编程语言 JavaScript 能做什么？ JavaScript 发展历史 JavaScript 标准参考教程 - JavaScript 语言的历史 JavaScript 的诞生 JavaScript 与 Ecmascript 的关系 JavaScript 与 Java 的关系 JavaScript 的版本 JavaScript 周边大事记 小结基本概念 语法 区分大小写 标识符 注释 严格模式 语句 关键字和保留字 变量 数据类型 typeof 操作符 Undefined Null Boolean Number String Object 操作符 流程控制语句 函数 JavaScript 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。 基本类型（值类型） Undefined Null Boolean Number String 复杂类型（引用类型） Object Array Date RegExp Function 基本包装类型 Boolean Number String 单体内置对象 Global Math 类型检测 typeof instanceof Object.prototype.toString.call() 值类型和引用类型在内存中的存储方式（画图说明） 值类型按值存储 引用类型按引用存储 值类型复制和引用类型复制（画图说明） 值类型按值复制 引用类型按引用复制 值类型和引用类型参数传递（画图说明） 值类型按值传递 引用类型按引用传递 值类型与引用类型的差别 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，复制的是值的副本 引用类型的值是对象，保存在堆内存 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象 小结 类型检测方式 值类型和引用类型的存储方式 值类型复制和引用类型复制 方法参数中 值类型数据传递 和 引用类型数据传递 JavaScript 执行过程JavaScript 运行分为两个阶段： 预解析 全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高） 函数内部预解析（所有的变量、函数和形参都会参与预解析） 函数 形参 普通变量 执行 先预解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。 JavaScript 面向对象编程 面向对象介绍什么是对象 Everything is object （万物皆对象） 对象到底是什么，我们可以从两次层次来理解。 (1) 对象是单个事物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 (2) 对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。 ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。 什么是面向对象 面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 面向对象与面向过程： 面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊 面向对象就是找一个对象，指挥得结果 面向对象将执行者转变成指挥者 面向对象不是面向过程的替代，而是面向过程的封装 面向对象的特性： 封装性 继承性 [多态性] 扩展阅读： 维基百科 - 面向对象程序设计 知乎：如何用一句话说明什么是面向对象思想？ 知乎：什么是面向对象编程思想？ 程序中面向对象的基本体现在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（ Class ）的概念。 我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示： 12var std1 = &#123; name: 'Michael', score: 98 &#125;var std2 = &#123; name: 'Bob', score: 81 &#125; 而处理学生成绩可以通过函数实现，比如打印学生的成绩： 123function printScore (student) &#123; console.log('姓名：' + student.name + ' ' + '成绩：' + student.score)&#125; 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是 Student 这种数据类型应该被视为一个对象，这个对象拥有 name 和 score 这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 printScore 消息，让对象自己把自己的数据打印出来。 抽象数据行为模板（Class）： 12345678function Student (name, score) &#123; this.name = name this.score = score&#125;Student.prototype.printScore = function () &#123; console.log('姓名：' + this.name + ' ' + '成绩：' + this.score)&#125; 根据模板创建具体实例对象（Instance）： 12var std1 = new Student('Michael', 98)var std2 = new Student('Bob', 81) 实例对象具有自己的具体行为（给对象发消息）： 12std1.printScore() // =&gt; 姓名：Michael 成绩：98std2.printScore() // =&gt; 姓名：Bob 成绩 81 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。 所以，面向对象的设计思想是： 抽象出 Class 根据 Class 创建 Instance 指挥 Instance 得结果 面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。 创建对象简单方式我们可以直接通过 new Object() 创建： 1234567var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建： 1234567var person = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 对于上面的写法固然没有问题，但是假如我们要生成两个 person 实例对象呢？ 123456789101112131415var person1 = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125;var person2 = &#123; name: 'Mike', age: 16, sayName: function () &#123; console.log(this.name) &#125;&#125; 通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。 简单方式的改进：工厂函数我们可以写一个函数，解决代码重复问题： 123456789function createPerson (name, age) &#123; return &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125;&#125; 然后生成实例对象： 12var p1 = createPerson('Jack', 18)var p2 = createPerson('Mike', 18) 这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数内容引导： 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 普通函数调用和构造函数调用的区别 构造函数的返回值 构造函数的静态成员和实例成员 函数也是对象 实例成员 静态成员 构造函数的问题 更优雅的工厂函数：构造函数一种更优雅的工厂函数就是下面这样，构造函数： 12345678910111213function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person('Jack', 18)p1.sayName() // =&gt; Jackvar p2 = new Person('Mike', 23)p2.sayName() // =&gt; Mike 解析构造函数代码的执行在上面的示例中，Person() 函数取代了 createPerson() 函数，但是实现效果是一样的。这是为什么呢？ 我们注意到，Person() 中的代码与 createPerson() 有以下几点不同之处： 没有显示的创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 函数名使用的是大写的 Person 而要创建 Person 实例，则必须使用 new 操作符。以这种方式调用构造函数会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码 返回新对象 下面是具体的伪代码： 12345678910111213141516function Person (name, age) &#123; // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象 // var instance = &#123;&#125; // 然后让内部的 this 指向 instance 对象 // this = instance // 接下来所有针对 this 的操作实际上操作的就是 instance this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125; // 在函数的结尾处会将 this 返回，也就是 instance // return this&#125; 构造函数和实例对象的关系使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。在每一个实例对象中的__proto__中同时有一个 constructor 属性，该属性指向创建该实例的构造函数： 123console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true 对象的 constructor 属性最初是用来标识对象类型的，但是，如果要检测对象的类型，还是使用 instanceof 操作符更可靠一些： 12console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true 总结： 构造函数是根据具体的事物抽象出来的抽象模板 实例对象是根据抽象的构造函数模板得到的具体实例对象 每一个实例对象都具有一个 constructor 属性，指向创建该实例的构造函数 注意： constructor 是实例的属性的说法不严谨，具体后面的原型会讲到 可以通过实例的 constructor 属性判断实例和构造函数之间的关系 注意：这种方式不严谨，推荐使用 instanceof 操作符，后面学原型会解释为什么 构造函数的问题使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： 1234567891011function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = function () &#123; console.log('hello ' + this.name) &#125;&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16) 在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 1console.log(p1.sayHello === p2.sayHello) // =&gt; false 对于这种问题我们可以把需要共享的函数定义到构造函数外部： 123456789101112131415function sayHello = function () &#123; console.log('hello ' + this.name)&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = sayHello&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; true 这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。 你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题： 12345678910111213141516171819202122var fns = &#123; sayHello: function () &#123; console.log('hello ' + this.name) &#125;, sayAge: function () &#123; console.log(this.age) &#125;&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = fns.sayHello this.sayAge = fns.sayAge&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; trueconsole.log(p1.sayAge === p2.sayAge) // =&gt; true 至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。但是代码看起来还是那么的格格不入，那有没有更好的方式呢？ 小结 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 构造函数的问题 原型内容引导： 使用 prototype 原型对象解决构造函数的问题 分析 构造函数、prototype 原型对象、实例对象 三者之间的关系 属性成员搜索原则：原型链 实例对象读写原型对象中的成员 原型对象的简写形式 原生对象的原型 Object Array String … 原型对象的问题 构造的函数和原型对象使用建议 更好的解决方案： prototypeJavascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 1234567891011121314151617function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.type = 'human'Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // =&gt; true 这时所有实例的 type 属性和 sayName() 方法，其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 构造函数、实例、原型三者之间的关系 任何函数都具有一个 prototype 属性，该属性是一个对象。 123456function F () &#123;&#125;console.log(F.prototype) // =&gt; objectF.prototype.sayHi = function () &#123; console.log('hi!')&#125; 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数。 1console.log(F.constructor === F) // =&gt; true 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。 12var instance = new F()console.log(instance.__proto__ === F.prototype) // =&gt; true __proto__ 是非标准属性。 实例对象可以直接访问原型对象成员。 1instance.sayHi() // =&gt; hi! 总结： 任何函数都具有一个 prototype 属性，该属性是一个对象 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__ 所有实例都直接或间接继承了原型对象的成员 属性成员的搜索原则：原型链了解了 构造函数-实例-原型对象 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性 搜索首先从对象实例本身开始 如果在实例中找到了具有给定名字的属性，则返回该属性的值 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性 如果在原型对象中找到了这个属性，则返回该属性的值 也就是说，在我们调用 person1.sayName() 的时候，会先后执行两次搜索： 首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。 ”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。 ”于是，它就读取那个保存在原型对象中的函数。 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。 而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 总结： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 实例对象读写原型对象成员读取： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 值类型成员写入（实例对象.值类型成员 = xx）： 当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上 也就是说该行为实际上会屏蔽掉对原型对象成员的访问 引用类型成员写入（实例对象.引用类型成员 = xx）： 同上 复杂类型修改（实例对象.成员.xx = xx）： 同样会先在自己身上找该成员，如果自己身上找到则直接修改 如果自己身上找不到，则沿着原型链继续查找，如果找到则修改 如果一直到原型链的末端还没有找到该成员，则报错（实例对象.undefined.xx = xx） 更简单的原型语法我们注意到，前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： 1234567891011function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 在该示例中，我们将 Person.prototype 重置到了一个新的对象。这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： 123456789101112function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; constructor: Person, // =&gt; 手动将 constructor 指向正确的构造函数 type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 原生对象的原型 所有函数都有 prototype 属性对象。 Object.prototype Function.prototype Array.prototype String.prototype Number.prototype Date.prototype … 练习：为数组对象和字符串对象扩展原型方法。 原型对象的问题 共享数组 共享对象 如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则就是问题。 一个更好的建议是，最好不要让实例之间互相共享这些数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。 原型对象使用建议 私有成员（一般就是非函数成员）放到构造函数中 共享成员（一般就是函数）放到原型对象中 如果重置了 prototype 记得修正 constructor 的指向 案例：随机方块 面向对象游戏案例：贪吃蛇案例相关源码以上传到 GitHub ：https://github.com/lipengzhou/new-snake 案例介绍游戏演示在线演示地址：贪吃蛇 案例目标游戏的目的是用来体会js高级语法的使用 不需要具备抽象对象的能力，使用面向对象的方式分析问题，需要一个漫长的过程。 功能实现搭建页面放一个容器盛放游戏场景 div#map，设置样式 123456#map &#123; width: 800px; height: 600px; background-color: #ccc; position: relative;&#125; 分析对象 游戏对象 蛇对象 食物对象 创建食物对象 Food 属性 x y width height color 方法 render 随机创建一个食物对象，并输出到map上 创建Food的构造函数，并设置属性 1234567891011var position = 'absolute';var elements = [];function Food(x, y, width, height, color) &#123; this.x = x || 0; this.y = y || 0; // 食物的宽度和高度(像素) this.width = width || 20; this.height = height || 20; // 食物的颜色 this.color = color || 'green';&#125; 通过原型设置render方法，实现随机产生食物对象，并渲染到map上 12345678910111213141516Food.prototype.render = function (map) &#123; // 随机食物的位置，map.宽度/food.宽度，总共有多少分food的宽度，随机一下。然后再乘以food的宽度 this.x = parseInt(Math.random() * map.offsetWidth / this.width) * this.width; this.y = parseInt(Math.random() * map.offsetHeight / this.height) * this.height; // 动态创建食物对应的div var div = document.createElement('div'); map.appendChild(div); div.style.position = position; div.style.left = this.x + 'px'; div.style.top = this.y + 'px'; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; div.style.backgroundColor = this.color; elements.push(div);&#125; 通过自调用函数，进行封装，通过window暴露Food对象 1window.Food = Food; 创建蛇对象 Snake 属性 width 蛇节的宽度 默认20 height 蛇节的高度 默认20 body 数组，蛇的头部和身体，第一个位置是蛇头 direction 蛇运动的方向 默认right 可以是 left top bottom 方法 render 把蛇渲染到map上 Snake构造函数 1234567891011121314var position = 'absolute';var elements = [];function Snake(width, height, direction) &#123; // 设置每一个蛇节的宽度 this.width = width || 20; this.height = height || 20; // 蛇的每一部分, 第一部分是蛇头 this.body = [ &#123;x: 3, y: 2, color: 'red'&#125;, &#123;x: 2, y: 2, color: 'red'&#125;, &#123;x: 1, y: 2, color: 'red'&#125; ]; this.direction = direction || 'right';&#125; render方法 12345678910111213Snake.prototype.render = function(map) &#123; for(var i = 0; i &lt; this.body.length; i++) &#123; var obj = this.body[i]; var div = document.createElement('div'); map.appendChild(div); div.style.left = obj.x * this.width + 'px'; div.style.top = obj.y * this.height + 'px'; div.style.position = position; div.style.backgroundColor = obj.color; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; &#125;&#125; 在自调用函数中暴露Snake对象 1window.Snake = Snake; 创建游戏对象游戏对象，用来管理游戏中的所有对象和开始游戏 Game 属性 food snake map 方法 start 开始游戏（绘制所有游戏对象） 构造函数 12345function Game(map) &#123; this.food = new Food(); this.snake = new Snake(); this.map = map;&#125; 开始游戏，渲染食物对象和蛇对象 1234Game.prototype.start = function () &#123; this.food.render(this.map); this.snake.render(this.map);&#125; 游戏的逻辑写蛇的move方法 在蛇对象(snake.js)中，在Snake的原型上新增move方法 让蛇移动起来，把蛇身体的每一部分往前移动一下 蛇头部分根据不同的方向决定 往哪里移动 1234567891011121314151617181920212223Snake.prototype.move = function (food, map) &#123; // 让蛇身体的每一部分往前移动一下 var i = this.body.length - 1; for(; i &gt; 0; i--) &#123; this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; &#125; // 根据移动的方向，决定蛇头如何处理 switch(this.direction) &#123; case 'left': this.body[0].x -= 1; break; case 'right': this.body[0].x += 1; break; case 'top': this.body[0].y -= 1; break; case 'bottom': this.body[0].y += 1; break; &#125;&#125; 在game中测试 12this.snake.move(this.food, this.map);this.snake.render(this.map); 让蛇自己动起来 私有方法 1234什么是私有方法？ 不能被外部访问的方法如何创建私有方法？ 使用自调用函数包裹 在game.js中 添加runSnake的私有方法，开启定时器调用蛇的move和render方法，让蛇动起来 判断蛇是否撞墙 1234567891011121314151617181920212223function runSnake() &#123; var timerId = setInterval(function() &#123; this.snake.move(this.food, this.map); // 在渲染前，删除之前的蛇 this.snake.render(this.map); // 判断蛇是否撞墙 var maxX = this.map.offsetWidth / this.snake.width; var maxY = this.map.offsetHeight / this.snake.height; var headX = this.snake.body[0].x; var headY = this.snake.body[0].y; if (headX &lt; 0 || headX &gt;= maxX) &#123; clearInterval(timerId); alert('Game Over'); &#125; if (headY &lt; 0 || headY &gt;= maxY) &#123; clearInterval(timerId); alert('Game Over'); &#125; &#125;.bind(that), 150);&#125; 在snake中添加删除蛇的私有方法，在render中调用 12345678910function remove() &#123; // 删除渲染的蛇 var i = elements.length - 1; for(; i &gt;= 0; i--) &#123; // 删除页面上渲染的蛇 elements[i].parentNode.removeChild(elements[i]); // 删除elements数组中的元素 elements.splice(i, 1); &#125;&#125; 在game中通过键盘控制蛇的移动方向 12345678910111213141516171819202122function bindKey() &#123; document.addEventListener('keydown', function(e) &#123; switch (e.keyCode) &#123; case 37: // left this.snake.direction = 'left'; break; case 38: // top this.snake.direction = 'top'; break; case 39: // right this.snake.direction = 'right'; break; case 40: // bottom this.snake.direction = 'bottom'; break; &#125; &#125;.bind(that), false);&#125; 在start方法中调用 1bindKey(); 判断蛇是否吃到食物123456789101112131415161718// 在Snake的move方法中// 在移动的过程中判断蛇是否吃到食物// 如果蛇头和食物的位置重合代表吃到食物// 食物的坐标是像素，蛇的坐标是几个宽度，进行转换var headX = this.body[0].x * this.width;var headY = this.body[0].y * this.height;if (headX === food.x &amp;&amp; headY === food.y) &#123; // 吃到食物，往蛇节的最后加一节 var last = this.body[this.body.length - 1]; this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;) // 把现在的食物对象删除，并重新随机渲染一个食物对象 food.render(map);&#125; 其它处理把html中的js代码放到index.js中避免html中出现js代码 自调用函数的参数1234(function (window, undefined) &#123; var document = window.document;&#125;(window, undefined)) 传入window对象 将来代码压缩的时候，可以吧 function (window) 压缩成 function (w) 传入undefined 在将来会看到别人写的代码中会把undefined作为函数的参数(当前案例没有使用)因为在有的老版本的浏览器中 undefined可以被重新赋值，防止undefined 被重新赋值 整理代码现在的代码结构清晰，谁出问题就找到对应的js文件即可。通过自调用函数，已经防止了变量命名污染的问题 但是，由于js文件数较多，需要在页面上引用，会产生文件依赖的问题(先引入那个js，再引入哪个js)将来通过工具把js文件合并并压缩。现在手工合并js文件演示 问题1 1234567891011121314// 如果存在多个自调用函数要用分号分割，否则语法错误// 下面代码会报错(function () &#123;&#125;())(function () &#123;&#125;())// 所以代码规范中会建议在自调用函数之前加上分号// 下面代码没有问题;(function () &#123;&#125;());(function () &#123;&#125;()) 问题2 123456789// 当自调用函数 前面有函数声明时，会把自调用函数作为参数// 所以建议自调用函数前，加上;var a = function () &#123; alert('11');&#125; (function () &#123; alert('22');&#125;()) 继承什么是继承 现实生活中的继承 程序中的继承 构造函数的属性继承：借用构造函数12345678910111213function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;function Student (name, age) &#123; // 借用构造函数继承属性成员 Person.call(this, name, age)&#125;var s1 = Student('张三', 18)console.log(s1.type, s1.name, s1.age) // =&gt; human 张三 18 构造函数的原型方法继承：拷贝继承（for-in）12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 原型对象拷贝继承原型对象成员for(var key in Person.prototype) &#123; Student.prototype[key] = Person.prototype[key]&#125;var s1 = Student('张三', 18)s1.sayName() // =&gt; hello 张三 另一种继承方式：原型继承12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 利用原型的特性实现继承Student.prototype = new Person()var s1 = Student('张三', 18)console.log(s1.type) // =&gt; humans1.sayName() // =&gt; hello 张三 函数进阶函数的定义方式 函数声明 函数表达式 new Function 函数声明123function foo () &#123;&#125; 函数表达式123var foo = function () &#123;&#125; 函数声明与函数表达式的区别 函数声明必须有名字 函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用 函数表达式类似于变量赋值 函数表达式可以没有名字，例如匿名函数 函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用 下面是一个根据条件定义函数的例子： 123456789if (true) &#123; function f () &#123; console.log(1) &#125;&#125; else &#123; function f () &#123; console.log(2) &#125;&#125; 以上代码执行结果在不同浏览器中结果不一致。 不过我们可以使用函数表达式解决上面的问题： 1234567891011var fif (true) &#123; f = function () &#123; console.log(1) &#125;&#125; else &#123; f = function () &#123; console.log(2) &#125;&#125; 函数的调用方式 普通函数 构造函数 对象方法 函数内 this 指向的不同场景函数的调用方式决定了 this 指向的不同： 调用方式 非严格模式 备注 普通函数调用 window 严格模式下是 undefined 构造函数调用 实例对象 原型方法中 this 也是实例对象 对象方法调用 该方法所属对象 紧挨着的对象 事件绑定方法 绑定事件对象 定时器函数 window 这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。 函数也是对象 所有函数都是 Function 的实例 call、apply、bind那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。这就是接下来我们要学习的 call、apply、bind 三个函数方法。 callcall() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 在 fun 函数运行时指定的 this 值 如果指定了 null 或者 undefined 则内部 this 指向 window arg1, arg2, ... 指定的参数列表 applyapply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：该方法的作用和 call() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.apply(thisArg, [argsArray]) 参数： thisArg argsArray apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数列表。例如： 1fun.apply(this, ['eat', 'bananas']) bindbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值： 返回由指定的this值和初始化参数改造的原函数拷贝。 示例1： 123456789101112131415this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 示例2： 12345678910111213141516function LateBloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// Declare bloom after a delay of 1 secondLateBloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 1000);&#125;;LateBloomer.prototype.declare = function() &#123; console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');&#125;;var flower = new LateBloomer();flower.bloom(); // 一秒钟后, 调用'declare'方法 小结 call 和 apply 特性一样 都是用来调用函数，而且是立即调用 但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向 call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可 apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递 如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window bind 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数 它和 call、apply 最大的区别是：bind 不会调用 bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递 在 bind 的同时，以参数列表的形式进行传递 在调用的时候，以参数列表的形式进行传递 那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部 函数的其它成员 arguments 实参集合 caller 函数的调用者 length 形参的个数 name 函数的名称 12345678910111213function fn(x, y, z) &#123; console.log(fn.length) // =&gt; 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // =&gt; 函数的名字&#125;function f() &#123; fn(10, 20, 30)&#125;f() 高阶函数 函数可以作为参数 函数可以作为返回值 作为参数12345678910function eat (callback) &#123; setTimeout(function () &#123; console.log('吃完了') callback() &#125;, 1000)&#125;eat(function () &#123; console.log('去唱歌')&#125;) 作为返回值1234567891011function genFun (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === type &#125;&#125;var isArray = genFun('[object Array]')var isObject = genFun('[object Object]')console.log(isArray([])) // =&gt; trueconsole.log(isArray(&#123;&#125;)) // =&gt; true 函数闭包1234567891011121314151617function fn () &#123; var count = 0 return &#123; getCount: function () &#123; console.log(count) &#125;, setCount: function () &#123; count++ &#125; &#125;&#125;var fns = fn()fns.getCount() // =&gt; 0fns.setCount()fns.getCount() // =&gt; 1 作用域、作用域链、预解析 全局作用域 函数作用域 没有块级作用域 12345678910&#123; var foo = 'bar'&#125;console.log(foo)if (true) &#123; var a = 123&#125;console.log(a) 作用域链示例代码： 123456789101112131415161718var a = 10function fn () &#123; var b = 20 function fn1 () &#123; var c = 30 console.log(a + b + c) &#125; function fn2 () &#123; var d = 40 console.log(c + d) &#125; fn1() fn2()&#125; 内层作用域可以访问外层作用域，反之不行 什么是闭包闭包就是能够读取其他函数内部变量的函数，由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 可以在函数外部读取函数内部成员 让函数内成员始终存活在内存中 一些关于闭包的例子示例1： 123456var arr = [10, 20, 30]for(var i = 0; i &lt; arr.length; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;&#125; 示例2： 12345678console.log(111)for(var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 0)&#125;console.log(222) 示例3：投票 示例4：判断类型 示例5：沙箱模式 闭包的思考题思考题 1： 1234567891011var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 思考题 2： 1234567891011var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function () &#123; var that = this; return function () &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 小结函数递归递归执行模型123456789101112131415161718192021222324function fn1 () &#123; console.log(111) fn2() console.log('fn1')&#125;function fn2 () &#123; console.log(222) fn3() console.log('fn2')&#125;function fn3 () &#123; console.log(333) fn4() console.log('fn3')&#125;function fn4 () &#123; console.log(444) console.log('fn4')&#125;fn1() 举个栗子：计算阶乘的递归函数1234567function factorial (num) &#123; if (num &lt;= 1) &#123; return 1 &#125; else &#123; return num * factorial(num - 1) &#125;&#125; 递归应用场景 深拷贝等 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ 验证邮编： 1^\d&#123;6&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn： 1^\w+@\w+\.\w+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;\(.\d&#123;1,3&#125;)&#123;3&#125;$ JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\d', 'i');var reg = new Regex('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); 正则提取123456789101112131415161718192021222324252627// 1. 提取工资var str = "张三：1000，李四：5000，王五：8000。";var array = str.match(/\d+/g);console.log(array);// 2. 提取email地址var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;var str = "123123@xx.com";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125; 正则替换123456789// 1. 替换所有空白var str = " 123AD asadf asadfasf adf ";str = str.replace(/\s/g,"xx");console.log(str);// 2. 替换所有,|，var str = "abc,efg,123，abc,123，a";str = str.replace(/,|，/g, ".");console.log(str); 案例：表单验证12345QQ号：&lt;input type="text" id="txtQQ"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type="text" id="txtEMail"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type="text" id="txtPhone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type="text" id="txtBirthday"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type="text" id="txtName"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById("txtQQ");var txtEMail = document.getElementById("txtEMail");var txtPhone = document.getElementById("txtPhone");var txtBirthday = document.getElementById("txtBirthday");var txtName = document.getElementById("txtName");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的QQ号"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\w+@\w+\.\w+(\.\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的EMail地址"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, "请输入正确的出生日期");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id="frm"&gt; QQ号：&lt;input type="text" name="txtQQ" data-rule="qq"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type="text" name="txtEMail" data-rule="email"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type="text" name="txtPhone" data-rule="phone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type="text" name="txtBirthday" data-rule="date"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type="text" name="txtName" data-rule="cn"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\d&#123;5,12&#125;$/, tip: "请输入正确的QQ" &#125;, &#123; name: 'email', reg: /^\w+@\w+\.\w+(\.\w+)?$/, tip: "请输入正确的邮箱地址" &#125;, &#123; name: 'phone', reg: /^\d&#123;11&#125;$/, tip: "请输入正确的手机号码" &#125;, &#123; name: 'date', reg: /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/, tip: "请输入正确的出生日期" &#125;, &#123; name: 'cn', reg: /^[\u4e00-\u9fa5]&#123;2,4&#125;$/, tip: "请输入正确的姓名" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125; 补充伪数组和数组在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。 对象与数组的关系在说区别之前，需要先提到另外一个知识，就是 JavaScript 的原型继承。所有 JavaScript 的内置构造函数都是继承自 Object.prototype 。在这个前提下，可以理解为使用 new Array() 或 [] 创建出来的数组对象，都会拥有 Object.prototype 的属性值。 1234var obj = &#123;&#125;;// 拥有 Object.prototype 的属性值var arr = [];//使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，//那么，它将同时拥有 Array.prototype 和 Object.prototype 的属性值 可以得到对象和数组的第一个区别：对象没有数组 Array.prototype 的属性值。 什么是数组数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码： 12345678910var obj = &#123;&#125;;var arr = []; obj[2] = 'a';arr[2] = 'a'; console.log(obj[2]); // =&gt; aconsole.log(arr[2]); // =&gt; aconsole.log(obj.length); // =&gt; undefinedconsole.log(arr.length); // =&gt; 3 obj[2]输出’a’，是因为对象就是普通的键值对存取数据 而arr[2]输出’a’ 则不同，数组是通过索引来存取数据，arr[2]之所以输出’a’，是因为数组arr索引2的位置已经存储了数据 obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined 而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值 为什么arr.length输出3，而不是1 在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数 什么是伪数组 拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法 伪数组，就是像数组一样有 length 属性，也有 0、1、2、3 等属性的对象，看起来就像数组一样，但不是数组，比如: 123456789101112var fakeArray = &#123; "0": "first", "1": "second", "2": "third", length: 3&#125;; for (var i = 0; i &lt; fakeArray.length; i++) &#123; console.log(fakeArray[i]);&#125; Array.prototype.join.call(fakeArray,'+'); 常见的伪数组有： 函数内部的 arguments DOM 对象列表（比如通过 document.getElementsByTags 得到的列表） jQuery 对象（比如 $(&quot;div&quot;) ） 伪数组是一个 Object，而真实的数组是一个 Array。 伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多方法，比如： 123456789101112var arr = Array.prototype.slice.call(arguments); Array.prototype.forEach.call(arguments, function(v) &#123; // 循环arguments对象&#125;);// push// some// every// filter// map// ... 以上在借用数组的原型方法的时候都可以通过数组直接量来简化使用： 1234567891011121314var obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;;[].push.call(obj, 'd')console.log([].slice.call(obj));[].forEach.call(obj, function (num, index) &#123; console.log(num)&#125;) 小结 对象没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array 数组是基于索引的实现， length 会自动更新，而对象是键值对 使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法 JavaScript 垃圾回收机制JavaScript 运行机制：Event LoopObject静态成员 Object.assign() Object.create() Object.keys() Object.defineProperty() 实例成员 constructor hasOwnProperty() isPrototypeOf propertyIsEnumerable() toString() valueOf() 附录A 代码规范代码风格 JavaScript Standard Style Airbnb JavaScript Style Guide() { 校验工具 JSLint JSHint ESLint B Chrome 开发者工具C 文档相关工具 电子文档制作工具: docute 流程图工具：DiagramDesigner]]></content>
  </entry>
  <entry>
    <title><![CDATA[内置对象]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[内置对象一、基本数据类型 与 引用数据类型的区别1.1 回顾【了解】 基本数据类型 ​ 指的是简单的数据类型，有数字Number、字符串String、布尔Boolean、未定义Undefined、空Null。 引用数据类型 ​ 指的是复杂的数据类型，有数组Array、函数Function、对象等。 1.2 内存中的栈和堆 【重点】 思考 1234567891011&gt; var num = 123; //基本数据类型&gt; var a = num;&gt; a = 456;&gt; console.log(num); //num?&gt;&gt;&gt; var arr = [11,22,33,44]; //引用数据类型&gt; var arr2 = arr;&gt; arr2[0] = '一一';&gt; console.log(arr[0]); //arr[0]？&gt; 栈和堆 内存可以分为栈区 和 堆区 栈区：用来存储用var关键字创建的变量名 和 基本类型的数据。 堆区：用来存储引用类型的数据。 1.3 基本数据类型在内存中的存储方式 【重点】 1.4 引用数据类型在内存中的存储方式 【重点】 二.内置对象2.1 对象分类 [了解] 思考？ 请描述内置对象、宿主对象和自定义对象的区别？ 内置对象 系统所提供的对象如：Object、Array、Math、Date等等。 宿主对象 JS所运行的环境提供的对象比如：BOM中的Window、DOM中的document； 自定义对象 自定义构造函数所创建的对象。 2.2 如何学习内置对象 【重点】 手册 MDN W3C在线或离线手册 如何学习一个对象中的方法？ 方法中功能 方法的参数和类型2 方法的返回值 demo 2.3 Math对象 【重要】 Math对象介绍 ​ Math本身就是一个对象，该对象中集合了很多关于数学运算的方法。也就是说，对于后期的一些复杂一些的数学运算，不需要自己动手去运算，直接调用Math对象中的方法实现即可 Math对象常用的方法 Math.abs(数字); 获取一个数字的绝对对象 Math.round(数字); 四舍五入 Math.PI; π Math.ceil(数字); 向上取整 Math.floor(数字); 向下取整 Math.random(); 随机数[0,1); Math.max(数字,数字,数字…); 求最大数 Math.min(数字,数字,数字…); 求最小数 2.4 Date类型对象 【重要】 Date类型对象介绍 Date类型对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）。 类型：Date 创建日期对象的方式： 12345678&gt; new Date(); //当前时间&gt;&gt; new Date(value); //value，传入的毫秒&gt;&gt; new Date(dateString); //字符串&gt;&gt; new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);// 数字&gt; Date类型对象常用的方法 获取设置年月日 1234567&gt; getFullYear() / setFullYear(数字) 年&gt;&gt; getMonth() / setMonth(数字) 月&gt; 注意：获取月份是从0开始的&gt;&gt; getDate() / setDate(数字) //日&gt; 获取星期几 12&gt; getDay(); //0-6（周日0到周六6）&gt; 获取设置时分秒毫秒 12345678&gt; getHours() / setHours(数字) 时&gt;&gt; getMinutes() / setMinutes(数字)分&gt;&gt; getSeconds() / setMinutes(数字) 秒&gt;&gt; getMilliseconds() / setMilliseconds(数字) 毫秒&gt; 获取设置毫秒1970年1月1日至今的毫秒 12&gt; getTime(); / setTime(数字);&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数、对象]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[函数、对象一. 函数1.1 函数体内的aruments 【了解】 思考 写一个函数，实现计算用户输入任意个数字的总和 ? aruments aruments，在函数体内可以使用。aruments中存放了所有的实参。 aruments的使用： 1234567891011121314&gt; function getSum()&#123;&gt; //arguments可以暂时看成是一个函数内部提供的数组，集合了所有的实参。&gt; //arguments.length; 参数的个数&gt; //arguments[下标]; //获取一个实参&gt; var sum = 0;&gt; for(var index = 0;index&lt;arguments.length;index++)&#123;&gt; sum = sum + arguments[index];&gt; &#125;&gt; return sum;&gt; &#125;&gt;&gt; var result = getSum(10,20,30,40,50);&gt; alert(result);&gt; 1.2 预解析 【重要】 思考： 思考1？： 12&gt; alert(a); //报错&gt; 思考2： 12345678&gt; /*&gt; 对于js的执行顺序，默认是自上而下执行。&gt; 对第一个alert(a)之前并没有创建变量。按道理应该报错。&gt; */&gt; alert(a); //但是不会报错&gt; var a = 123;&gt; alert(a); &gt; 思考3： 123456&gt; fn(); //报错&gt; //函数表达式&gt; var fn = function()&#123;&gt; alert(1);&gt; &#125;;&gt; 思考4： 123456&gt; fn(); //不报报错&gt; //函数声明&gt; function fn() &#123;&gt; alert(1); &gt; &#125;&gt; 什么是预解析 ​ 程序准备→执行。程序在执行之前，有个预备过程。 预备过程要做的事就是预解析。预备过程要做两件事，分别是： 把用var关键字所声明的变量名（仅仅是变量名），提升到当前执行环境的顶部。 把用函数声明所创建的函数（函数整体），提升到当前执行环境的顶部。 ​ 1.3 作用域 【重要】 什么是作用域？ 作用域，指的是变量或函数调用的使用范围。 全局作用域 什么是全局作用域？ 函数之外的执行环境，就是全局作用域。 全局变量 在全局作用域中用var关键字所创建的变量，就是全局变量。 全局变量的作用范围是程序中的任何地方。 1234567&gt; &gt; var a = 123; //a是全局变量&gt; &gt; function fn() &#123;&gt; &gt; alert(a); //123;&gt; &gt; &#125;&gt; &gt; fn();&gt; &gt; alert(a); //123;&gt; &gt; 局部作用域 什么是局部作用域？ 函数体内的环境，就是局部作用域。 局部变量 在局部作用域中用var关键字所创建的变量，就是局部变量。局部变量的作用范围是，仅仅是本函数体内使用。 123456&gt; &gt; function fn()&#123;&gt; &gt; var a = 123;&gt; &gt; alert(a);&gt; &gt; &#125;&gt; &gt; alert(a); //报错&gt; &gt; 函数的形参可以看成是局部变量 12345&gt; &gt; function fn(a) &#123;&gt; &gt; alert(a);&gt; &gt; &#125;&gt; &gt; alert(a); //报错&gt; &gt; 再看预解析 思考？ 12345678&gt; &gt; var a = 123;&gt; &gt; function fn()&#123;&gt; &gt; console.log(a); //a的值 undefined;&gt; &gt; var a = 456;&gt; &gt; &#125;&gt; &gt; fn();&gt; &gt; console.log(a); //a的值 123&gt; &gt; 预解析中的变量提升，说是提升到当前执行环境的顶部。 当前执行环境指的是当前作用域。 在局部作用域中使用一个变量时，若局部变量 和 全局变量重名时，在局部作用域中会优先使用局部变量。 作用域链 代码 123456789101112131415&gt; var a = 1;&gt; function fn1()&#123;&gt; var a = 2;&gt; var b = '2b';&gt; function fn2()&#123;&gt; var a = 3;&gt; function fn3()&#123;&gt; var a = 4;&gt; console.log(a); //a的值 ?&gt; consoe.log(b); //b的值 ?&gt; &#125;&gt; &gt; &#125;&gt; &#125;&gt; 图解作用域链 什么是作用域链？​ 当访问一个变量时，会先从本作用域中去找这个变量中去找，若找不到则向上一级作用域中去找，依次类推，就形成了一个作用域链。 图解 JS中没有块级作用域 【扩展】 什么是块级作用域 ​ 在其他编程语言中，如java、c#等，在if语句、循环语句中创建的变量，仅仅只能在本if语句、本循环语句中使用。如下Java代码 123456&gt; &gt; if(true)&#123;&gt; &gt; int num = 123;&gt; &gt; system.out.print(num); //123;&gt; &gt; &#125;&gt; &gt; system.out.print(num); //报错&gt; &gt; JS中没有块级作用域 JS中没有块级作用域【ES5版本之前】 123456&gt; &gt;if(true)&#123;&gt; &gt; var num = 123;&gt; &gt; console.log(123); //123&gt; &gt;&#125;&gt; &gt;console.log(123); //123;&gt; &gt; ​ 1.4 回调函数 【重要】 回顾函数的参数 形参 实参 函数也是数据，类型是 Function 什么是回调函数 回调函数，就是函数可以当做实参传递给另一个函数的实参并在另一个函数内部中调用。 1234567891011&gt; /*&gt; 方式一：&gt; */&gt; function fn(f)&#123;&gt; f();&gt; &#125;&gt; var test = function()&#123;&gt; alert('执行');&gt; &#125;&gt; fn(test);&gt; ​ 1234567891011&gt; /*&gt; 方式二：&gt; */&gt; function fn(f)&#123;&gt; f();&gt; &#125;&gt;&gt; fn(function()&#123;&gt; alert('执行');&gt; &#125;);&gt; ​ 1.5 匿名函数和自执行函数 【重点】 匿名函数 匿名函数就是没有名字的函数。在js中匿名函数需要配合运算符使用。如： 123456789101112131415&gt; //匿名函数 常用&gt; (function()&#123;&gt; alert(1);&gt; &#125;);&gt;&gt; //匿名函数&gt; !function()&#123;&gt; alert(1);&gt; &#125;;&gt;&gt; //匿名函数&gt; -function()&#123;&gt; alert(1);&gt; &#125;;&gt; 自执行函数（自调用函数） 自执行函数就是匿名函数创建后马上执行。 123456789101112131415&gt;//匿名函数 常用&gt;(function()&#123;&gt; alert(1);&gt;&#125;)();&gt;&gt;//匿名函数&gt;!function()&#123;&gt; alert(1);&gt;&#125;();&gt;&gt;//匿名函数&gt;-function()&#123;&gt; alert(1);&gt;&#125;();&gt; 匿名函数和自定义函数的优点 可以模拟块级作用域 可以避免全局变量污染​ 二. 对象2.1 为什么要学习对象 【了解】 ​ 后面的很多知识点都是通过对象调用出来的，所以我们必须务必知道对象组织数据的方式。 2.2 什么是对象 【重要】 对象的概念 从两个层面理解： 生活层面，对象是单个事物抽象出来的实例。 ​ “万物皆对象”，一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 数据层面，对象是一个容器，封装了属性和方法。 对象是一种数据，属于引用类型的数据 属性：对象的静态特征。 方法：对象的动态特征。 2.3 对象的创建方式 【重要】 类和对象 类 抽象出的模板。 对象 具体的实例。 类和对象的关系 类是对象的模板，对象是类的实例。对象需要通过类来创建：具体语法如下 12&gt; &gt; var 对象名 = new 类名();&gt; &gt; 方式一：通过Object类创建 Object 类是系统提供的一个类，可以直接使用。 代码： 12345678910&gt; var hero1 = new Object(); //空的对象，里面属性和方法&gt; //字面量创建&gt; //var hero1 = &#123;&#125;; //和new Object()性质一样，空的对象，里面属性和方法&gt; hero1.name = '孙悟空';&gt; hero1.age = 18;&gt; hero1.attack = function()&#123;&gt; alert(this.name + '发动攻击...');&gt; &#125;&gt; hero01.attack();&gt; 方式二：通过自定义构造函数创建（自定义类） 在es6之前，js中没有类的概念，但可以通过构造函数模拟。 构造函数 构造函数，可以用来创建并初始化对象。 语法： 1234567891011121314151617&gt; //创建构造函数。和普通函数创建方式一样，当命名时首字母要大写（帕斯卡命名）&gt; function 函数名(参数1,参数2...)&#123;&gt; //this表示通过new创建的哪个当前的对象&gt; this.键 = 参数1;&gt; this.键 = 参数2;&gt; ...&gt; &#125;&gt;&gt; //通过构造函数创建对像&gt; var 对象1 = new 函数名(实参1,实参2...);&gt; &gt; //new 关键字执行的过程&gt; ① 在函数体内创建一个空的对象（看不见）&gt; ② 让当前this指向这个空的对象&gt; ③ 通过this给当前空的对象添加键值对&gt; ④ 返回已经添加好所有键值对的对象给外面的变量。（看不见）&gt; 代码： 12345678910111213141516171819202122232425&gt; /*&gt; 自定义构造函数（类） Hero&gt; */&gt; function Hero(name,age)&#123;&gt; this.name = name;&gt; this.age = age;&gt; this.sayHi = function()&#123;&gt; console.log('我叫' + this.name + ',我今年' + this.age + '岁');&gt; &#125;&gt; this.attack = function()&#123;&gt; console.log(this.name + '发动攻击...')&gt; &#125;&gt; &#125;&gt;&gt; /*&gt; 通过自定义构造函数创建对象&gt; */&gt; var wuKong = new Hero('孙悟空',18);&gt; wuKong.sayHi();&gt; wuKong.attack();&gt;&gt; var baJie = new Hero('猪八戒',20);&gt; baJie.sayHi();&gt; wuKong.attack();&gt; 2.4 对象的操作 【重要】 对象组织数据的方式： 对象组织数据的方式是： 键值对象。 键，指的是属性名或方法名。 值，指的是实际的数据。 给对象增加属性和方法： 对象名.键名 = 值; 对象名[‘键名’] = 值; 代码： 12345678&gt; var dog1 = &#123;&#125;;&gt; dog1.name = '旺财'; //属性&gt; dog1['age'] = 1; //属性&gt; dog1.call = function()&#123; //方法&gt; alert(this.name + '在汪汪叫...')&gt; &#125;&gt; //注意，方法要用函数来表示&gt; 访问对象中的属性和方法： 对象.键名; 对象[‘键名’]; 代码： 1234567891011&gt; var dog1 = &#123;&#125;;&gt; dog1.name = '旺财'; //属性&gt; dog1['age'] = 1; //属性&gt; dog1.call = function()&#123; //方法&gt; alert(this.name + '在汪汪叫...')&gt; &#125;&gt; //注意，方法要用函数来表示&gt; dog1.call(); //调用&gt; console.log(dog1['name']);&gt; console.log(dog1.age);&gt; 删除对象中的属性和方法： delete 对象.键名; delete 对象[‘键名’]; 代码： 12345678910111213141516&gt; var dog1 = &#123;&gt; name:'旺财',&gt; age:1,&gt; call:function()&#123;&gt; alert(this.name + '在汪汪叫...')&gt; &#125;&gt; &#125;;&gt; //删除之前访问&gt; console.log(dog1.name); //旺财&gt; //删除&gt; delete dog.name;&gt; //删除之后访问&gt; console.log(dog1.name); //undefiend&gt; //检测对中是否还要name属性&gt; console.log(dog1.hasOwnProperty('name')); //false;&gt; 检测一个对象中是否存在某个属性或方法： 对象.hasOwnProperty(‘键名’); //返回boolean值，false表示不存在，true表示存在 遍历对象中的键值对 遍历方式 for-in 12345&gt; for(var key in 对象)&#123;&gt; //key 是对象中的每一个键&gt; //对象[key]; &gt; &#125;&gt; 代码 12345678910&gt; var student1 = &#123;&gt; name:'张三',&gt; age:17,&gt; gender:'男',&gt; scroe:100&gt; &#125;;&gt; for(var key in student1)&#123;&gt; console.log(student1[key]);&gt; &#125;&gt; 检测一个对象的数据类型 对象是引用数据类型，检测对象时不要用typeof去检测，要用instanceof 12&gt; 对象 instanceof 构造函数名; //返回boolean值，true表示属于，false表示不属于&gt; 代码 12345678910111213&gt; /*&gt; 创建构造函数 Person&gt; */&gt; function Person(name,age,gender)&#123;&gt; this.name = name;&gt; this.age = age;&gt; this.gender = gender;&gt; &#125;&gt; // 创建一个Person类型的对象 p1&gt; var p1 = new Person('张三',17,'男');&gt; //检测对象p1是否属于Person&gt; console.log(p1 instanceof Person); //true&gt; 2.5 this 指向问题 【重要】 this 介绍 this是一个关键字，这个关键字在程序执行时会指向不同的对象。也就是说这个this到底指向谁？得看程序的执行情况。 构造函数和普通函数调用时，this指向不同的对象 this指向 window对象 1234567&gt; function Person()&#123;&gt; this.name = '张三';&gt; console.log(this); //window&gt; &#125;&gt; // Person当做普通函数调用&gt; Person();&gt; this指向被创建的实例对象 1234567&gt; function Person()&#123;&gt; this.name = '张三';&gt; console.log(this); //Person类型的一个实例对象&gt; &#125;&gt; //Person当做构造函数调用&gt; var p1 = new Person();&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组、函数]]></title>
    <url>%2F2018%2F06%2F20%2F%E6%95%B0%E7%BB%84%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数组、函数一. 数组1.1 为什么学习数组 【了解】 思考：​ 之前学习的数据类型，只能存储一个值(比如：Number/String）。我们想存储班级中所有学生的姓名，此时该如何存储？ 1234567&gt;var name1 = '张三';&gt;var name2 = '李四';&gt;var name3 = '王五';&gt;var name4 = '赵六';&gt;//...&gt;//缺点：变量声明太多，造成代码冗余，数据难易维护和管理。&gt; 1.2 数组的概念 【了解】 什么是数组？ ​ 所谓数组，就是将多个数据（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组中的数据是有序的 ​ 数组是一个有序的列表，可以在数组中存放任意的数据，并且数组的长度可以动态的调整。注意：这里的顺序指的是数组中每个数据的编号。 数组是一个引用类型的数据 ​ 数组也是数据，将来也会存放在内存中。数组可以集合多个数据，是属于引用类型的数据。 1.3 数组的创建和使用【重要】 创建数组 数组有两种创建方式，今天先学习一种。 语法： 123&gt; var 变量名 = []; //空的数组&gt; var 变量名 = [数据,数据,数据...]; //一组数据&gt; 代码： 123&gt; //用数组存放一组名字&gt; var names = ['张三','李四','王五','赵六','陈七','刘八','秦九'];&gt; 访问数组中的数据 语法 123456&gt; //数组中的数据是有下标的（索引或编号），下标是有序的，从0开始。&gt; // 下标 0 1 2 3 ...&gt; var 数组名 = [数据,数据,数据,数据...];&gt; //通过下标获取数组中指定的数据&gt; 数组名[下标];&gt; 代码 1234567&gt; //数组，存放一组名字&gt; var names = ['张三','李四','王五','赵六','陈七','刘八','秦九'];&gt; //获取 李四&gt; console.log(names[1]);&gt; //获取 赵六&gt; console.log(names[3]);&gt; 数组的长度 数组的长度，指的数组中数据的个数。 语法： 12&gt; 数组名.length;&gt; 代码： 12345&gt; //数组，存放一组名字&gt; var names = ['张三','李四','王五','赵六','陈七','刘八','秦九'];&gt; //获取数组中存储了少个人的名字&gt; console.log(names.length); //7&gt; 修改数组中的数据 语法： 12&gt; 数组名[下标] = 数据;&gt; 代码： 12345&gt; var names = ['张三','李四','王五','赵六','陈七','刘八','秦九'];&gt; //把数组中的第一个数据 '张三' 修改为 'zhangsan'&gt; names[0] = 'zhangsan';&gt; console.log(names[0]); //zhangsan&gt; 向数组中新增数据 语法： 12&gt; 数组名[数组名.length] = 数据;&gt; 代码： 12345&gt; var names = ['张三','李四','王五','赵六','陈七','刘八','秦九'];&gt; //给数组新添加一个数据&gt; names[names.length] = '周十';&gt; console.log(names); //'张三','李四','王五','赵六','陈七','刘八','秦九',周十&gt; 遍历数组 遍历数组，就是通过循环的方式获取数组中的每一个数据 遍历方式： for 循环 语法： 1234&gt; for(var 变量 = 0;变量&lt;数组名.length;变量++) &#123;&gt; //数组名[变量]&gt; &#125;&gt; 代码： 12345&gt; var names = ['张三','李四','王五','赵六','陈七','刘八','秦九'];&gt; for(var index = 0;index&lt;names.length;index++)&#123;&gt; console.log(names[index]);&gt; &#125;&gt; 1.4 冒泡排序 【了解】 什么是冒泡排序？ ​ 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 ​ 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 ​ 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。 图解冒泡排序 二.函数2.1 为什么学习函数 思考： 如果要在多个地方求1-100之间所有偶数，应该怎么做？ 2.2 函数的概念和作用 函数的概念 函数，简单理解就是一个功能、方法，功能可以反复调用。也是一种数据，属于引用数据类型的数据，类型为Function 函数的作用 封装性，将执行代码封闭在一个独立的执行环境中。可以反复调用，减少代码冗余。 2.3 函数的创建和调用 语法： 函数声明 12345678&gt; //创建函数方式一&gt; function 函数名()&#123; //函数名和变量名的命名规则规范一样 &gt; //函数体&gt; &#125;&gt; //函数创建完后，函数体中的代码不会执行，只用调用时才会执行&gt; //调用函数&gt; 函数名();&gt; 函数表达式 1234567&gt; //创建函数方式二&gt; var 函数名 = function()&#123;&gt; //函数体&gt; &#125;&gt; //调用函数&gt; 函数名();&gt; 代码： 123456789101112&gt; //创建函数&gt; function getEven()&#123;&gt; for(var num = 1;num&lt;=100;num++)&#123;&gt; if(num%2==0)&#123;&gt; document.write(num + '&lt;br&gt;');&gt; &#125;&gt; &#125;&gt; &#125;&gt;&gt; //调用函数&gt; getEven();&gt; 2.4 函数的参数 思考 计算n-m之间所有数字的和？ 参数 参数可用分为形参和实参 形参，在函数创建时，在小扩号中定义的标识符。 实参，在函数调用时，在小扩号中所传入的实际的数据。 语法 函数声明 123456&gt; function 函数名(形参,形参,形参...) &#123;//形参，就是一个占位符，命名规则和规范和变量一样&gt; //函数体&gt; &#125;&gt;&gt; 函数名(数据,数据,数据...); //实参，就是实际的数据&gt; 函数表达式 123456&gt; var 函数名 = function(形参,形参,形参...) &#123;//形参，就是一个占位符，命名规则和规范和变量一样&gt; //函数体&gt; &#125;&gt;&gt; 函数名(数据,数据,数据...); //实参，就是实际的数据&gt; 代码 123456789101112131415&gt; // 需求： n-m之间所有数字的和&gt; /*&gt; 形参：&gt; n:起始数字&gt; m:终止数字&gt; */&gt; function getSum(n,m)&#123;&gt; var sum = 0;&gt; for(var num = n;n&lt;=m;n++)&#123;&gt; sum+=n;&gt; &#125;&gt; document.write('总和是：' + sum);&gt; &#125;&gt; getSum(1,100);&gt; 2.5 函数的返回值 思考？ 在不同的地方以不同的颜色打印出任意n-m之间所有数字的和。 return 关键字 作用： 123&gt; ① 可以终止函数的执行。&gt; ② 可以将数据返回。&gt; 语法： 12345678&gt; // return 关键字，要在函数体内使用&gt; function 函数名(形参列表) &#123;&gt; //函数体内没有return时; 函数默认返回undefined&gt; //return 数据; //终止函数，并返回数据。&gt; //return; //终止函数，并返回undefined&gt; &gt; &#125;&gt; 代码 12345678910&gt; function getSum(n,m)&#123;&gt; var sum = 0;&gt; for(var num = n;n&lt;=m;n++)&#123;&gt; sum+=n;&gt; &#125;&gt; return sum;&gt; &#125;&gt;&gt; var result = getSum(1,100); //函数调用完后会返回结果&gt; ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[js基础语法02]]></title>
    <url>%2F2018%2F06%2F10%2Fjs%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%9502%2F</url>
    <content type="text"><![CDATA[JavaScript语法基础02一. 表达式和语句1.1 表达式 【了解】 什么是表达式？ ​ 一个表达式可以产生一个值，有可能是运算、函数调用、有可能是字面量。表达式可以放在任何需要值的地方。 1234&gt; '张三'=='李四'; //true&gt; 20*2+4; //44&gt; '不要在年轻的时候选择安逸'; //字面量&gt; 常识 只能操作一个值的操作符叫一元操作符,组成的表达式叫一元表达式.(一个值一个运算符) 由两个值和一个运算符连接起来的表达式叫二元表达式。(两个值一个运算符) 由三个值和两个运算符连接起来的表达式叫三元表达式.(三个值两个运算符) 12345&gt; -1; //一元表达式&gt; 1 + 1; //二元表达式&gt; var age = 18;&gt; age&gt;=18?'成年':'未成年'; //三元表达式&gt; 1.2 语句 【了解】 什么是语句？ ​ 语句可以理解为一个行为，循环语句和判断语句就是典型的语句。一个程序有很多个语句组成，一般情况下;分割一个一个的语句。 12&gt; var age = 18; //这是一个赋值的行为，把18赋值给变量age&gt; 二. 流程控制2.1 什么是流程控制？【重要】 简单来说，就是控制程序的执行顺序。对于流程控制，可以分为三种结构。分别是： 顺序结构 分支结构 循环结构 2.2 顺序结构 【了解】 顺序结构，指的是js程序默认的执行顺序（自上而下）。 12345&gt; document.write(1);&gt; document.write(2);&gt; document.write(3);&gt; document.write(4);&gt; 2.3 分支结构 【重要】 分支结构，根据不同的情况，执行不同的代码。 单分支结构 语法 123456&gt; if(条件表达式)&#123;&gt; //执行语句&gt; &#125;&gt;&gt; //当条件表达式成立时，也就是条件表达式的最终结果是true时，就进入大括号中执行代码。否则，当条件表达式不成立时，也就是条件表达式的最终结果是false时，就不会进入大括号中执行代码。&gt; 代码 1234567&gt; // 需求：接收用户所输入的年龄，若年龄大于等于18，就给用户显示一张图片。&gt; var age = prompt('请输入你的年龄');&gt; if(age&gt;=18)&#123;&gt; document.write('&lt;img src="wc.jpg"&gt;')&gt; &#125;&gt; //调试观察程序的执行流程&gt; 双分支结构 语法 12345678&gt; if(条件表达式)&#123;&gt; //条件成立，要执行的代码&gt; &#125;else &#123;&gt; //条件不成立，要执行的代码&gt; &#125;&gt;&gt; //当条件表达式成立时，就执行if中的代码。否则，执行else中的代码。两者必定执行其中一个。&gt; 代码 1234567891011&gt; // 需求：接收用户所输入的年龄，若年龄大于等于18，就给用户显示一张图片。否则，告诉用户年龄太小，不宜观看。&gt;&gt; var age = prompt('请输入你的年龄');&gt; if(age&gt;=18) &#123;&gt; docuemnt.write('&lt;img src="wc.jpg"&gt;');&gt; &#125;else &#123;&gt; alert('年龄太小，不宜观看');&gt; &#125;&gt;&gt; //调试观察程序的执行流程&gt; 多分支结构 语法 123456789101112&gt; if(条件表达式)&#123;&gt; // 执行语句&gt; &#125;else if(条件表达式)&#123;&gt; // 执行语句&gt; &#125;else if(条件表达式)&#123;&gt; // 执行语句&gt; &#125;... else &#123;&gt; //执行语句&gt; &#125;&gt;&gt; // 从第一个if开始条件表达式判断，若成立则跳过整个多分支语句。若不成立，则开始判断第二个条件表达式判断，依次类推。 若以上if判断都不成立，则最终执行最后一个else中的代码。对于最后的else可有可无（按需使用）&gt; 代码 12345678910111213141516&gt; // 需求：接收班长口袋里的钱数？若大于等于2000，请大家吃西餐。若小于2000，大于等于1500，请大家吃快餐。若小于1500，大于等于1000，请大家喝饮料。若小于1000，大于等于500，请大家吃棒棒糖。否则提醒班长下次把钱带够&gt; var money = prompt('班长口袋里的钱');&gt; if(money&gt;=2000)&#123;&gt; alert('吃西餐');&gt; &#125;else if(money&gt;=1500)&#123;&gt; alert('吃快餐');&gt; &#125;else if(money&gt;=1000) &#123;&gt; alert('喝饮料');&gt; &#125;else if(money&gt;=500)&#123;&gt; alert('吃棒棒糖');&gt; &#125;else &#123;&gt; alert('班长，下次带够钱');&gt; &#125;&gt;&gt; //调试观察程序的执行流程&gt; switch结构 语法 1234567891011121314151617181920&gt; switch(传入的值)&#123;&gt; case 值1:&gt; //执行语句&gt; break;&gt; case 值2:&gt; //执行语句&gt; break;&gt; case 值3:&gt; //执行语句&gt; break;&gt; /*...*/&gt; default:&gt; //执行语句&gt; break;&gt; &gt; &#125;&gt; //做等值（全等）判断，让传入的值和以下各种值的情况比较，符合执行应的代码。否则依次向下比较。若以上的值都不成立，则执行default(可有可无，按需使用)对应的代码。&gt;&gt; //break关键字，可有可无，按需使用。当执行了break关键字时，会结束switch结构&gt; 代码 123456789101112131415161718192021222324252627&gt; //需求：接收用户输入的月份，根据月份告诉用户当前的季节3、4、5月为春季，6、7、8月为夏季，9、10、11月为秋季，12、1、2月为冬季。&gt; var month = prompt('请输入月份');&gt; switch(month)&#123;&gt; case "3":&gt; case "4":&gt; case "5":&gt; alert('春季');&gt; break;&gt; case "6":&gt; case "7":&gt; case "8":&gt; alert('夏季');&gt; break;&gt; case "9":&gt; case "10":&gt; case "11":&gt; alert('秋季');&gt; break;&gt; case "12":&gt; case "1":&gt; case "2":&gt; alert('冬季');&gt; break;&gt; default:&gt; alert('你输入的月份不合法');&gt; &#125;&gt; switch结构 和 多分支结构的区别 switch结构仅仅只能做等值判断。 多分支结构，既可以做等值判断，也可以做其他判断。 当对于多种情况，全都是等值判断时，可以选择使用switch，因为siwtch对于等值判断结构更加清晰，执行速度要比多分支结构要快一些。 三元表达式 语法 123&gt; 条件表达式 ? 结果1:结果2;&gt; //当条件成立时，执行结果1，否则执行结果2。 是对if-else双分支语句的简写。 不过建议使用if-else,因为if-else结构更加清晰。&gt; 代码 1234&gt; // 需求：接收用户所输入的年龄，若年龄大于等于18，就给用户显示一张图片。否则，告诉用户年龄太小，不宜观看。&gt; var age = prompt('请输入你的年龄');&gt; age&gt;=18?document.write('&lt;img src="wc.jpg"&gt;'):alert('年龄太小，不宜观看');&gt; 2.4 循环结构 【重要】 什么是循环？ 循环，就是重复的意思。在程序中，通过循环可以重复的执行一段程序。问题： 12&gt; 打印&quot;我爱你&quot;一万次到页面中 ？ 怎么做？&gt; while 循环 语法 12345&gt; while(条件表达式)&#123;&gt; //循环体&gt; &#125;&gt; //当条件成立时，会执行循环体中的代码。然后再返回判断条件是否成立，周而复始。直到条件不成立时，结束当前循环&gt; 代码 1234567&gt; var count = 1; //初始化变量count为1；&gt; while(count&lt;=10000)&#123;&gt; document.write('&lt;h2&gt;我爱你&lt;/h2&gt;');&gt; count++;&gt; &#125;&gt; //调试观察代码的执行流程&gt; 图解while循环执行流程 do-while 循环 语法 123456&gt; do &#123;&gt; //循环体&gt; &#125;while(条件表达式);&gt;&gt; //先执行一次循环体，然后是否周而复始的执行循环体，根据条件表达式是否成立决定。&gt; 代码 1234567&gt; var count = 1;&gt; do &#123;&gt; document.write('&lt;h2&gt;我爱你&lt;/h2&gt;');&gt; count++;&gt; &#125;while(count&lt;=10000)&gt; //调试观察代码的执行流程&gt; 图解do-while循环执行流程 for 循环 【一般for循环用的比较多】 语法 123456&gt; //每个表达式用分号;分割，千万不要写成逗号,&gt; for(初始化表达式1;条件表达式2;自增表达式3)&#123;&gt; //循环体4&gt; &#125;&gt; //执行顺序： 1 2 4 3 → 2 4 3 → 2 4 3 ...&gt; 代码 12345&gt; for(var count = 1;count&lt;=10000;count++) &#123;&gt; document.write('&lt;h2&gt;我爱你&lt;/h2&gt;');&gt; &#125;&gt; ////调试观察代码的执行流程&gt; 图解for循环执行流程 break 和 continue break 关键字 作用：可以结束当前整个循环 代码 123456789101112&gt; //需求：接收用户输入的用户名和密码，若用户名为 “admin” ,密码为 “123456” ,提示用户登录成功! 否则，让用户是指输入正确为止！&gt; while(true)&#123;&gt; var userName = prompt('请输入用户名');&gt; var pwd = prompt('请输入密码');&gt; if(userName=='admin'&amp;&amp;pwd=='123456')&#123;&gt; alert('登录成功');&gt; break;&gt; &#125;else &#123;&gt; alert('用户名或密码错误，请重新输入');&gt; &#125;&gt; &#125;&gt; continue关键字 作用：结束当前这一次的循环，并开始下一次循环 代码 12345678&gt; //打印 100以内所有的偶数&gt; for(var num = 1;num&lt;=100;num++)&#123;&gt; if(num%2!=0)&#123;&gt; continue;&gt; &#125;&gt; console.log(num);&gt; &#125;&gt; 三种循环的相同点和不同点 相同点： 都是循环 不同点 不论条件是否成立，循环体必须执行一次，用do-while循环 当循环次数不确定时，选用while循环更加简单些 当循环次数确定时，一般选择使用for循环 死循环 永无休止的循环就是“死循环”，在程序中要避免“死循环” 1234&gt; while(1==1) &#123;&gt; console.log('我爱你');&gt; &#125;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS语法基础01]]></title>
    <url>%2F2018%2F05%2F25%2Fjs%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[JavaScript语法基础 01 一. JavaScript介绍1.1 为什么要学习JS ? JavaScript 起初的目的 1JavaScript起初出现的目的是为了做一些简单的表单验证。 JavaScript现在的意义 1234567JS现在的应用几乎无处不在。 → PC Web 页面特效 → 移动端（web App, 混合 App） → AJAX （异步和服务器交互） → 后端开发 （NodeJS） → 游戏、vr、智能家电、AI ... 演示 效果： 内衣公司广告 程序员给女朋友制定的相册 频危动物的申诉 … 游戏：水果忍者飞机大战 游戏编程… 应用 百度脑图QQ邮箱网页版微信网页版QQ … 1.2 JS是一门编程语言 编程语言 123→ 具有逻辑描述能力的语言就是编程语言。逻辑指的是数学逻辑和业务逻辑。→ HTML和CSS不是编程语言，因为它们不具有逻辑描述能力。→ JavaScript是一门解释型的、弱类型的、基于原型的编程语言。 解释型和@编译型编程语言【扩展】 源代码和二进制 1我们所写的源代码是我们人类能够看的懂的，但计算机看不懂，计算机只认识二进制0和1。若想要让计算机能够识别我们所写的源代码，需要一个翻译官把我们的源代码翻译成二进制再交给计算机执行。 解释型编程语言 1234567特点：翻译一句，执行一句。常见的解释型的编程语言有：PHP、JavaScript等。优点：开发效率高。缺点：程序性能相对低一些。适合用来开发一些应用级别的软件。 编译型编程语言 1234567特点：全部翻译好，再执行。 常见的编译型编程语言有：c、c++等。 优点：程序性能较高。适合开发一些系统级别的软件。 缺点：开发效率低。 弱类型与强类型编程语言 弱类型编程语言 123456789特点： 弱类型编程语言在用变量引用数据时，变量所代表的数据的类型在执行时由由值来决定。常见的编程语言：PHP、JavaScript等JS代码示例： var a = 123; //变量a代表的数据类型是数字。 a = '小明'; //变量a代表的数据类型是字符串。优点：弱类型编程语言比较灵活。 强类型编程语言 123456789特点：强类型编程语言在用变量引用数据时，该变量必须得先声明要引用的数据的数据类型。在使用时该变量只能引用指定类型的数据。否则会报错。也就是说变量所代表的数据的数据类型在代码定义时决定的。常见的编程语言：Java、C#、C等c#代码示例： int a = 123; //变量a代码的数据是整数类型的数字。 a = &apos;小明&apos;; // 会报错。优点：稳定。 1.3 JS历史 JavaScript 问世 1上世纪90年代，NetScape(网景)公司研发的NetScape Navigator1.0(浏览器)成为当时最热门的浏览器。市场份额一举超过90%。 ​ 123Netscape公司很快发现，Navigator浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。1995年，Netscape公司雇佣了程序员Brendan Eich（布兰登·艾奇）开发这种网页脚本语言，JavaScript1.0。1996年3月，Navigator 2.0浏览器正式内置了JavaScript脚本语言。 “邪恶的” 后来者 1因为 JavaScript1.0 如此成功，所以微软也决定进军浏览器，1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape的注册商标，微软不能用），首先内置于IE 3.0。Netscape公司面临丧失浏览器脚本语言的主导权的局面。 标准的重要 1在微软进入后，有 3 种不同的 JavaScript 版本同时存在：NetscapeNavigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase。与 C 和其他编程语言不同的是， JavaScript 并没有一个标准来统一其语法或特性，而这 3 种不同的版本恰恰突出了这个问题。 随着业界担心的增加，这个语言标准化显然已经势在必行。 JavaScript标准化 123 1996年11月，Netscape公司决定将JavaScript提交给国际标准化组织ECMA（European Computer Manufacturers Association欧洲计算机制造商协会），希望JavaScript能够成为国际标准，以此抵抗微软。1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。注：ECMAScript 仅仅只是语法 1.4 JS组成部分 123456789 → ECMAScript 标准语法。 → DOM（Document Object Model）文档对象模型。 提供了操作网页中的html和css的工具（API）。将来可以通过js语法调用。 → BOM（Browser Object Model）浏览器对象模型。 提供了操作浏览器的工具（API）。将来可以通过js语法调用。 备注：API全称 Application Programming Interface 应用程序编程接口 二. JS的书写方式2.1 行内JS123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 行内js，写在标签中，一般配合事件使用。在实际开发中不推荐使用。 事件，和网页交互的行为。 如：鼠标点击、鼠标移动、鼠标离开、键盘按下等。 鼠标点击按钮时，弹出数字1。 --&gt; &lt;button onclick="alert(1)"&gt;按钮&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2.2 内部JS123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- ① 内部js，在head标签或body标签中使用script标签。 ② 标签： &lt;script type="text/javascript"&gt; js代码 &lt;/script&gt; 标签的type属性目的告诉浏览器，该标签中是js代码。type属性在html5版本中可以省略。 ③ 优点：减少和html代码的耦合。 --&gt; &lt;script&gt; alert(1); //弹出数字1 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 在body标签中使用script标签--&gt; &lt;script&gt; alert(2); //弹出数字2 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.3 外联JS html文件代码 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- ① 外联js,在head标签或body标签中使用script标签。 ② 标签： &lt;script src='js文件路径'&gt;&lt;/script&gt; ③ 优点：彻底和html分离，便于后期代码的维护。 --&gt; &lt;script src="base.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; JS文件（base.js）代码 1alert(1); 三. JS输出内容方式 和 注释3.1 JS输出内容的方式 方式一：警告框弹出, alert(‘内容’); 代码 12//弹出数字1alert('1'); 效果图 方式二：控制台打印, console.log(‘内容’); 代码 12//控制台打印 '你好'console.log('你好'); 效果图 方式三：网页中打印，document.write(‘内容’); 代码 12345//网页中打印 '你好'。document.write('你好');//网页中也可以打印带有标签的内容。document.write('&lt;h1&gt;你好&lt;/h1&gt;'); 效果图 方式四： 输出提示信息，接收用户输入的内容。 prompt(‘提示信息’); 代码 12//提示并接收用户所输入信息prompt('请输入您的年龄'); 效果图 3.2 JS注释 单行注释 12// 单行注释。 控制台打印console.log('你好'); 多行注释 12345/* 多行注释。 控制台打印。*/console.log('你好'); ​ 四. 代码规范123① 代码要缩进，建议缩进2个空格。② 一般情况下，每条语句后要加分号。③ 一般情况下，每条语句要独占一行。 五. JS代码执行顺序 和 调试5.1 JS代码执行顺序 代码 123456//JS代码默认的执行顺序是自上而下执行的。//代码： document.write('1'); document.write('2'); document.write('3'); document.write('4'); 效果图 5.2 调试 【重要】 为什么需要调试？ ​ 在开发开发工程中，难免会遇到bug。bug无非两种，一种是语法报错，语法错误时浏览器会告诉我们在什么地方报的错；另一种是逻辑错误，逻辑错误不同于语法报错，逻辑错误浏览器无法告诉我们在什么地方逻辑错误。需要我们手动的去调试发现问题。​ 所以调试可以帮助我们去解决问题。 调试的步骤 步骤一：在谷歌浏览器中鼠标右键，选择检查，打开开发者面板，选中soruces项，打开并显示我们的源代码。 步骤二：在指定js代码处对应的行号单击设置断点。 ​ 步骤三：刷新点击下一步手动控制代码的执行过程。 六. 计算机的组成部分6.1 软件 【了解】 应用软件 QQ 浏览器 Word sublime、webstrom 系统软件 Windows 系统 Linux 系统 Mac OSX 系统 6.2 硬件 【了解】 三大件 CPU 用来做运算处理，比如程序中的加减乘除等运算。 内存 运行中的程序中的数据会临时存放到内存中。特点：临时存储数据。当计算机关机再开机时，内存中数据就不存在了。 硬盘 计算机上所有的内容都会存放到硬盘中。特点：永久性存储数据。 当计算机关机再开机时，硬盘中内容依然存在 输入设备 鼠标 键盘 手写板 摄像头 … 输出设备 显示器 打印机 投影仪 … 6.3 软硬件关系图 【了解】 七. 变量7.1 认识数据 数据 JavaScript之所以称为编程语言，是因为JavaScript具有逻辑描述能力。而逻辑描述中更多的是运算。运算操作的就是数据。 什么是数据呢？ 从输出角度，能够被输出的内容就是数据。 从数据类型角度，数据一定是有类型的。 初步认识数字和字符串 Number 数字类型 就是阿拉伯数字，正数、负数、0 都是数字。如：1; 2; -100; 0; 3.14 String 字符串类型 用单引号或双引号所包裹的字符就是字符串。如：‘张三’; ‘abc’; “你好”; 程序在运行时，数据会临时存放到内存中。 123456789&lt;script&gt; /* 程序在运行时，程序中的数据会被临时分配到内存中。每个数据在内存中都会占据一定的空间大小。 */ 1; 3.14; '张三'; '李四';&lt;/script&gt; 7.2 字面量12345678&lt;script&gt; /* 什么是字面量？ 字面量，也被称为直接量。简单来说就是能够直接使用的数据就是字面量。 */ 1; //数字字面量 '你好'; //字符串字面量&lt;/script&gt; 7.3 为什么需要变量 问题 用js程序描述100次 1+1 运算，并在控制台输出。 代码 1234567&gt; &lt;script&gt;&gt; document.write(1+1);&gt; document.write(1+1);&gt; document.write(1+1);&gt; ...&gt; &lt;/script&gt;&gt; 内存分配图 缺点：​ 既然运算的数据都是1，为什么不在内存中只存放一个数字1，然后重复使用那一个数字1呢？每一次运算都在内存中开辟新的空间存放新的1，造成了内存使用的浪费。 7.4 变量的创建和使用 什么是变量？ 变量就是能够关联到内存中数据的标识符。用来获取和修改内存中数据。 变量的创建和使用 创建变量，关键字 var 12345&gt; &lt;script&gt;&gt; //创建一个变量&gt; var age;&gt; &lt;/script&gt;&gt; 变量的赋值 1234567&gt; &lt;script&gt;&gt; //创建一个变量&gt; var age;&gt; //给变量赋值&gt; age = 123;&gt; &lt;/script&gt;&gt; 变量初始化 12345&gt; &lt;script&gt;&gt; //创建一个变量并赋值&gt; var age = 123；&gt; &lt;/script&gt;&gt; 变量的批量创建 和 批量赋值 12345&gt; &lt;script&gt;&gt; var age,name,sex;&gt; age = 17,name = '张三',sex = '男';&gt; &lt;/script&gt;&gt; 变量的批量初始化 1234&gt; &lt;script&gt;&gt; var age = 17,name = '张三', sex = '男';&gt; &lt;/script&gt;&gt; 变量的重复赋值（喜新厌旧） 12345678910&gt; &lt;script&gt;&gt; /*&gt; 一个变量可以重复赋值。变量最终的结果是最后一次的赋值。&gt; */&gt; var age = 123;&gt; console.log(age); //123;&gt; age = 456;&gt; console.log(age); //456;&gt; &lt;/script&gt;&gt; 一个变量可以赋值给另一个变量 123456&gt; &lt;script&gt;&gt; var a = 123;&gt; var b = a;&gt; console.log(b); //123;&gt; &lt;/script&gt;&gt; 变量的使用 12345678&gt; &lt;script&gt;&gt; /*&gt; 使用变量就直接调用变量的名字&gt; */&gt; var age = 17;&gt; alert(age); //把变量age所代表的数据输出&gt; &lt;/script&gt;&gt; 7.5 图解变量和内存中数据的关系 【重要】 7.6 变量的命名规范 和 规则 【重要】 规则（法律） 变量名可以由数字、字母、下划线_、$符组成，但不能以数字开头。 不能使用关键字或保留字当做变量名。 变量名区分大小写。 规范（道德） 驼峰命名法，变量名若由多个单词组成，第一个单词的首字母要小写，后面其他单词的首字母要大写。如： 1var userName = 'admin'; 定义的变量名要顾名思义。 12//定义一个变量age代表年龄var age = 18; 7.7 关键字和保留字 【了解】 关键字 具有特殊含义的字符 保留字 ECMAScript 后期发展可能会用到的新的字符ES3.0 ES5.0 ES6.0 八. 数据类型8.1 数据类型介绍 【重要】 基本数据类型 基本数据类型，是指简单的数据类型。有五种，分别是： 数字 → Number 字符串 → String 布尔 → Boolean 未定义 → Undefined 空 → Null 引用数据类型 引用数据类型，是指复杂的数据类型。有很多种，比如： 数组 → Array 日期 → Date 对象 → Object … 8.2 Number 数字类型 【重要】 数字字面量 就是直接的数字。如： 123456&gt; 1;&gt; 10;&gt; 3.14;&gt; -1;&gt; 0;&gt; 进制 十进制 【常用】 序列范围 0-9 十进制数字： 0;1;2;3;4;5;6;7;8;9;10;11;12;13;100;200;-100等 八进制 【了解】 序列范围 0-7 八进制数字： 八进制数字表示必须以0为前缀表示如：01; 02; 03; 04; 05; 06; 07; 等 注意：在参与运算或使用时，八进制会自动转成十进制来运算。 十六进制 【了解】 序列范围：0-9及a-f 十六进制数字: 十六进制数字表示必须以0x为前缀表示 如：0x0; 0x1; 0x2; 0x3 0x4; 0x5; 0xa;等 注意：在参与运算或使用时，十六进制会自动转成十进制来运算。 浮点数（小数） 浮点数就是小数。 如：3.14; -2.2等; 浮点数的精度 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数,浮点数在运算的时候会出现精度丢失的问题，因此在做比较运算的时候，尽量不要用小数进行比较。 123&gt; 0.3 - 0.1 = ?; &gt; 0.1 + 0.2 = ?;&gt; 数值范围(了解) 由于内存的限制，ECMAScript 并不能保存世界上所有的数值。JavaScript不能表示世界上所有的数，因此在JavaScript中，数值大小是有一定限制的。 12345&gt; 最小值：Number.MIN_VALUE，这个值为： 5e-324；（科学计数法：5乘以10的负的324次方）&gt; 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308&gt; 无穷大：Infinity （正数数字和0相除的结果）&gt; 无穷小：-Infinity （负数数字和0相除的结果）&gt; NaN NaN 表示Not a Number，不是一个数字。但却是Number类型。 isNaN(数据); 检测一个数据是否是NaN；是返回true，不是返回false; ​ 8.3 String 字符串类型 【重要】 什么是字符串？ 用单引号或者双引号所包裹的字符就是字符串。如： 1234&gt; "张三";&gt; '李四';&gt; '他大舅他二舅都是他舅';&gt; 单双引号嵌套 思考？ 如何打印以下字符串？ ​ 我是一个”正直”的人​ 我很喜欢”黑马’程序猿’ ​ 单双引号嵌套 如：单引号嵌套双引号 123&gt; &gt; //此时被嵌套的双引号就是字符串中的普通字符&gt; &gt; '程序"猿"';&gt; &gt; ​ 如：双引号嵌套单引号 123&gt; &gt; //此时被嵌套的单引号就是字符串中的普通字符&gt; &gt; "程序'媛'";&gt; &gt; 转义符 思考 如何打印以下字符串？​ 我很喜欢”传’智’播客” 转义符 字符串拼接 将两个字符串拼接在一起如：“我爱你” 和 “祖国” 拼接成 “我爱你祖国” 拼接符（连接符） + 12&gt; console.log('我爱你' + '祖国');&gt; 8.4 Boolean 布尔类型 【重要】 仅有两个值，表示程序中的肯定和否定 123&gt; true; //表示程序中的肯定&gt; false; //表示程序中的否定&gt; 什么情况产生或使用布尔值? 在比较判断或逻辑判断中可以选择使用布尔值。 8.5 Undefined和Null类型【重要】 Undefined 仅有一个值：undefined,表示未定义; 1234&gt; &gt; //当创建好一个变量没有赋值时，变量的默认值是undefined;&gt; &gt; var num;&gt; &gt; console.log(num); //undefined&gt; &gt; Null 仅有一个值：null，表示空; GC，垃圾回收机制（Garbage Collection） ​ 数据在内存中占据空间，但是对于没有用的数据（不在被使用的数据，不在被变量关联的数据），GC会不断的去检测，若发现没有用的数据则会把没有用的数据从内存中消除。节省空间。 ​ 但有时我们需要手动的将数据从内存中释放，怎样释放？手动将变量的值改为null 8.6 检测数据的数据类型【重要】 typeof(数据); 返回数据的数据类型如： 1234&gt; &gt; typeof('abc'); //string&gt; &gt; typeof(true); //boolean&gt; &gt; typeof(1123); //number&gt; &gt; 九. 运算符9.1 算术运算符 【重要】 加 + 减 - 乘 * 除 / 取余数 % 123456789101112131415&gt; var result1 = 1 + 2; &gt; console.log(result1); //3&gt;&gt; var result2 = 4 - 2; &gt; console.log(result2); //1&gt;&gt; var result3 = 2 * 2; &gt; console.log(result3); //4&gt;&gt; var result4 = 10 / 5; &gt; console.log(result4); //2&gt;&gt; var result5 = 3 % 2; &gt; console.log(result5); //1&gt; 9.2 赋值运算符 【重要】 赋值 = 12&gt; &gt; var age = 18; //把数据18赋值给变量age&gt; &gt; 复合赋值 +=、-=、*=、/=、%= 12345&gt; &gt; //针对的是变量&gt; &gt; var num = 10;&gt; &gt; num+=2; //num = num + 2;&gt; &gt; console.log(num); //12&gt; &gt; 9.3 关系运算符 【重要】 关系运算符也就是比较运算符,比较的结果始终都是布尔值 运算符 大于 &gt; 小于 &lt; 大于等于 &gt;= 小于等于 &lt;= 等于 == 不等于 != 全等 === 不全等 !== 12345&gt; &gt; console.log(1&gt;2); //false&gt; &gt; console.log(3&gt;=1); //true&gt; &gt; console.log(1==1); //true&gt; &gt; console.log(1!=1); //false&gt; &gt; == 和 ===的区别 12345&gt; &gt; // == 比较的是值&gt; &gt; console.log(1=='1'); //true;&gt; &gt; // === 不仅比较值，还有比较数据类型&gt; &gt; console.log(1==='1'); // false;&gt; &gt; 9.4 逻辑运算符 【重要】 且 &amp;&amp; 表示并且，组合两个条件 语法格式： 条件1 &amp;&amp; 条件2 如果 &amp;&amp; 两边的条件结果都是true，结果就是true。其他情况都是false 1234&gt; &gt; &gt; console.log(1==1 &amp;&amp; 2==2); //true&gt; &gt; &gt; console.log(10&gt;9 &amp;&amp; 20&lt;=20); //true&gt; &gt; &gt; console.log('张三'=='李四' &amp;&amp; 1==1); //false&gt; &gt; &gt; 或 || 表示或者，组合两个条件 语法格式：条件1 || 条件2 如果 ||两边的条件结果都是false，结果就是false。其他情况都是true 123&gt; &gt; &gt; console.log(1==2 || 3==3); //true&gt; &gt; &gt; console.log('张三'=='李四' || 18&lt;17); //false&gt; &gt; &gt; 非 ! 表示取反。 语法格式： !条件 对true取反就是false，对false取反就是true 123&gt; &gt; &gt; !(1==1); //false&gt; &gt; &gt; !('张三'=='李四'); //true;&gt; &gt; &gt; 9.5 一元运算符 【重要】 什么是一元运算符？ 操作数只有一个的运算符就是一元运算符 一元运算符 非 ! 123&gt; &gt; !true;&gt; &gt; !false;&gt; &gt; 自增 ++ 针对的是变量，在变量原有的基础之上自增1,可以分为前自增和后自增 12345678&gt; &gt; &gt; var num = 10;&gt; &gt; &gt; ++num; //前自增&gt; &gt; &gt; console.log(num); //11&gt; &gt; &gt;&gt; &gt; &gt; var num2 = 10;&gt; &gt; &gt; num2++; //后自增&gt; &gt; &gt; console.log(num2); //11&gt; &gt; &gt; 前自增与后子增的区别 123456789101112131415&gt; &gt; &gt; /*&gt; &gt; &gt; 前自增在参与其他运算时，先自增得出结果，再参与运算。&gt; &gt; &gt; 后子增在参与其他运算时，先参与运算，再自增得出结果。&gt; &gt; &gt; */&gt; &gt; &gt;&gt; &gt; &gt; //前自增&gt; &gt; &gt; var num = 10;&gt; &gt; &gt; var result = ++num + 2;&gt; &gt; &gt; console.log(result); //13;&gt; &gt; &gt;&gt; &gt; &gt; //后子增&gt; &gt; &gt; var num2 = 10;&gt; &gt; &gt; var result2 = num++ + 2;&gt; &gt; &gt; console.log(result2); //12;&gt; &gt; &gt; ​ 自减 – 针对的是变量，在变量原有的基础之上自减1,可以分为前自减和后自减 12345678&gt; &gt; &gt; var num = 10;&gt; &gt; &gt; --num; //前自减&gt; &gt; &gt; console.log(num); //9&gt; &gt; &gt;&gt; &gt; &gt; var num2 = 10;&gt; &gt; &gt; num2--; //后自减&gt; &gt; &gt; console.log(num2); //9&gt; &gt; &gt; 前自减与后子减的区别 123456789101112131415&gt; &gt; &gt; /*&gt; &gt; &gt; 前自减在参与其他运算时，先自减1得出结果，再参与运算。&gt; &gt; &gt; 后子减在参与其他运算时，先参与运算，再自减1得出结果。&gt; &gt; &gt; */&gt; &gt; &gt;&gt; &gt; &gt; //前自减&gt; &gt; &gt; var num = 10;&gt; &gt; &gt; var result = --num + 2;&gt; &gt; &gt; console.log(result); //11;&gt; &gt; &gt;&gt; &gt; &gt; //后子减&gt; &gt; &gt; var num2 = 10;&gt; &gt; &gt; var result2 = num-- + 2;&gt; &gt; &gt; console.log(result2); //12;&gt; &gt; &gt; ​ 负号 - 12&gt; &gt; cosole.log(-1);&gt; &gt; 9.6 运算符的优先级 【重要】 优先级从高到底 12345678&gt; 1. () 优先级最高&gt; 2. 一元运算符 ++ -- ! +（正） -（负）&gt; 3. 算术运算符 先* / % 后 + -&gt; 4. 关系运算符 &gt; &gt;= &lt; &lt;=&gt; 5. 相等运算符 == 、 != 、 === 、!=&gt; 6. 逻辑运算符 先&amp;&amp; 后||&gt; 7. 赋值运算符&gt; 十. 数据类型转换10.1 数据类型转换介绍 【了解】 ​ 在程序中，任何类型的数据之间都可以参与运算符的。比如数字可以和字符串参与运算，字符串可以和布尔值参与参数等等。 ​ 总而言之，任何不同类型的数据之间可以参与任何不同的运算。 如：案例，接收用户说输入的年龄，在用户年龄原有的基础之上加5. 1234&gt; var age = prompt('请输入你的年龄'); //加入用户输入的是10&gt; age = age + 5; &gt; console.log(age); //结果是 105，为什么？如何解决？&gt; 10.2 强制转换 【重要】 什么是强制转换？ 就是手动的通过转换工具将一个数据转换成另一种类型的数据。 其他类型数据转数字 Number Number(其他数据); 1234567891011121314151617181920212223242526272829&gt; //数值字符串转数字&gt; var result1 = Number('123');&gt; console.log(result1);//123&gt; console.log(typeof(result1)); //number&gt;&gt; //非数值字符串转数字&gt; var result2 = Number('abc');&gt; console.log(result2); //NaN,'abc'整体不是数值，转换不了正常的数字。&gt; console.log(typeof(result2)); //number&gt;&gt; //非数值字符串转数字&gt; var result3 = Number('12abc');&gt; console.log(result2); //NaN,'12abc'不是数值，转换不了正常的数字&gt; console.log(typeof(result2)); //number&gt;&gt; //布尔值转数字&gt; var result4 = Number(true); &gt; var result5 = Number(false); &gt; console.log(result4) //1&gt; console.log(result5) //0&gt;&gt; //undefined 转数字&gt; var result6 = Number(undefined);&gt; console.log(result6); //NaN&gt;&gt; //null 转数字&gt; var result7 = Number(null);&gt; console.log(result7); //0&gt; parseInt(其他数据); 12345678910111213141516171819202122232425262728293031&gt; //与Number工具不同是，parseInt能将正常的字符串数值转换为整数&gt;&gt; //数值字符串转数字&gt; var result1 = parseInt('123.34');&gt; console.log(result1);//123&gt; console.log(typeof(result1)); //number&gt;&gt; //非数值字符串转数字&gt; var result2 = parseInt('abc');&gt; console.log(result2); //NaN,'abc'整体不是数值，转换不了正常的数字。&gt; console.log(typeof(result2)); //number&gt;&gt; //非数值字符串转数字&gt; var result3 = parseInt('12abc');&gt; console.log(result2); //12,会把最前面的数字提取出来&gt; console.log(typeof(result2)); //number&gt;&gt; //布尔值转数字&gt; var result4 = parseInt(true); &gt; var result5 = parseInt(false); &gt; console.log(result4) //NaN&gt; console.log(result5) //NaN&gt;&gt; //undefined 转数字&gt; var result6 = parseInt(undefined);&gt; console.log(result6); //NaN&gt;&gt; //null 转数字&gt; var result7 = parseInt(null);&gt; console.log(result7); //NaN&gt; parseFloat(其他数据); ​ 与parseInt不同的是，可以将正常的小数字符串数值转换成数字类型的小数，其他情况都和parseInt相同。 1234&gt; var result1 = parseFloat('3.14');&gt; console.log(result1); //3.14&gt; console.log(typeof(result1)); //number&gt; 其他类型数据转字符串 String 所有的数据在转换成字符串时，其实就是在其他数据两边加上双引号或单引号。 变量名.toString(); 123456789101112131415161718&gt;&gt; //数字转字符串&gt; var num = 123;&gt; var result1 = num.toString();&gt; console.log(result1); //"123";&gt;&gt; //布尔值转字符串&gt; var flag = true;&gt; var flag2 = false;&gt; console.log(flag.toString()); //"true"&gt; console.log(flag2.toString());//"false"&gt;&gt; //在使用变量.toString()方法时，变量的值不能为undefined和null，否则会报错&gt; var a = null;&gt; a.toString(); //报错&gt;&gt; //其他 略&gt; String(其他数据); 123456&gt; var result1 = String(123); //'123';&gt; var result2 = String(true); //'true';&gt; var result3 = String(NaN); //'NaN';&gt;&gt; //其他情况 略&gt; 其他数据类型转布尔 Boolean Boolean(其他数据) 注意：null、undefined、0、NaN、’’ 转换为boolean结果为false,其他的数据转换的结果为true。 12345678&gt; Boolean(null); //false&gt; Boolean(''); //false&gt; //其他略&gt;&gt; Boolean('我'); //true&gt; Boolean(123); //true&gt; //其他略&gt; 10.3 隐式转换 【重要】 什么叫做隐式转换？ ​ 隐式转换，也被称为自动转换。就是在程序运行过程中，不需要我们手动转换，数据会根据运算情况自动的转换为其他类型的数据。 其他数据转数字 Number 在做算术运算时（除了和字符串做相加运算外），其他非数字类型的数据会自动的转换为Number类型的数据。就相当于悄悄的，看不见的用Number(其他数据)转换为数字。 ​ 任何数据和NaN做运算（除了和字符串做相加运算外），结果始终都是NaN。 123456&gt; var result1 = '2' - 1; //字符串 '2' 自动转换为数字 2&gt; console.log(result1); // 1;&gt;&gt; var result2 = '3a' - 1; //字符串 '3a' 自动转换为数字 NaN&gt; console.log(result2); // NaN&gt; 其他数据转字符串 String ​ 任何数据和字符串做相加运算时，其他非字符串数据会自动的转换为String类型的数据。就相当于悄悄的，看不见的用String(其他数据)转换为字符串。 123&gt; var result1 = true + '我'; // 布尔值 true 自动转换为字符串 'true'&gt; console.log(result1); // 'true我'&gt; 其他数据转布尔 Boolean 在取反、选择语句 和 循环语句中的条件表达式中，其他数据会自动的转换为布尔值。就相当于悄悄的，看不见的用Boolean(其他数据)转换为布尔值。 ​ 1234&gt; console.log(!1); //false ; 数字1 转换为boolean值为 true,对true取反就是false&gt; consoel.log(!(1&gt;=2)); //true&gt;&gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Todos-vuejs]]></title>
    <url>%2F2018%2F04%2F02%2FTodos-vuejs%2F</url>
    <content type="text"><![CDATA[效果地址：https://coffeehouse1122.github.io/Todos-vuejs/ 源码地址：https://github.com/CoffeeHouse1122/Todos-vuejs]]></content>
  </entry>
  <entry>
    <title><![CDATA[2.16纪念]]></title>
    <url>%2F2018%2F03%2F31%2F2-16%E7%BA%AA%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[效果网址 ：https://coffeehouse1122.github.io/216LoveDay.github.io/ 源码地址 ：https://github.com/CoffeeHouse1122/216LoveDay.github.io]]></content>
  </entry>
  <entry>
    <title><![CDATA[3.29]]></title>
    <url>%2F2018%2F03%2F29%2F3-29%2F</url>
    <content type="text"><![CDATA[酷夏将至。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
